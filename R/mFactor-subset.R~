
# ------------------------------------------------
# assignment and subseting
# ------------------------------------------------

#' @export
`[[.mfactor` <- function(x,value){
	# the getter method
	if(length(value)>1)
		stop('attempt to select more than one element')
	if(length(value)<1)
		stop('attempt to select less than one element')
	if(inherits(value,'characer')){
		if(!value %in% names(x))
			stop(' subscript out of bounds')
		value <- which(names(x) == value)
	}
	if(!inherits(value,c('numeric','integer')))
		stop(' subscript out of bounds')
	out <- rbind(unclass(x)[value,])
	at <- attributes(x)
	at$dim <- dim(out)
	attributes(out) <- at
	out
}

#-- `[[.mfactor` <- function(x,...){
#-- 	# the getter method
#-- 	y <- NextMethod("[[")
#-- 	attr(y, "levels") <- attr(x, "levels")
#-- 	attr(y, "mlevels") <- attr(x, "mlevels")
#-- 	class(y) <- oldClass(x)
#-- 	y
#-- }

#' @export
#' @method [ mfactor
`[.mfactor` <- function(x,value){
	if(inherits(value,'characer')){
		if(any(!value %in% names(x)))
			stop(' subscript out of bounds')
		value <- which(names(x) %in% value)
	}
	if(!inherits(value,c('numeric','integer')))
		stop(' subscript out of bounds')
	out <- rbind(unclass(x)[value,])
	at <- attributes(x)
	at$dim[1] <- length(value)
	attributes(out) <- at
	out
}

#' @export
#' @method [<- mfactor
`[<-.mfactor` <- function (x, ..., value) {

#-- 	if(any(sapply(list(...), 
#-- 				  function(x)any(is.na(x)))))
	if(any(is.na(...)))
		stop('NAs are not allowed in subscripted assignments')
	# some constants
	lx <- levels(x)
	.missingRow <- rbind(rep_len(NA,length(lx)))
	.noneRow <- rbind(rep_len(F,length(lx)))

	na.FLAG <- FALSE
	# a utility function
	getlevel <- function(value){
		if(!length(value))
			return(.noneRow)
		if(all(is.na(value)))
			return(.missingRow)
		if(!all(value %in% lx)) {
			na.FLAG <<- TRUE
			return(.missingRow)
		}
		return(rbind(lx %in% value ))
	}
	if(inherits(value,c('mfactor','factor')))
		if(!identical(levels(x), levels(value)))
			stop('level sets are not equal')

	if(inherits(value,'mfactor')){
		.Matrix <- unclass(value)
	}else if(inherits(value,'factor')){
		.Matrix <- matrix(F,length(value),length(lx))
		.Matrix[cbind(seq_along(value),
					  unclass(value))] <- TRUE
		.Matrix[is.na(value),] <- NA
	} else if(is.list(value)){
		.Matrix <- do.call(base::rbind,lapply(value,getlevel))
	} else if(inherits(value,c('character'))){
		.Matrix <- getlevel(value)
	} else {
		stopifnot(inherits(value,c('integer','numeric')))
		.Matrix <- matrix(F,length(value),length(lx))
	}

	browser()
	if(na.FLAG)
		warning("invalid factor level, NAs generated")

	# sript the attributes, assign the new values, then reassign the attributes
	out <- as.matrix(x)

	.AT <- attributes(x)
	MAXrows <- max(...)
	if(MAXrows > nrow(out)){
		tmp<-matrix(NA,MAXrows,ncol(out))
		tmp[seq(nrow(out)),] <- out
		out<-tmp
		rm(tmp)
		.AT$dim[1]<-(MAXrows)
	}
	
	.len  <-  length(...)
	if(.len > 1 ){
		if(nrow(.Matrix) == 1 ){
			.Matrix<-matrix(rep_len(.Matrix,
									ncol(.Matrix)*.len),
							.len,,T)
		}else
			stop('replacement is not length 1 or equal to the number of items to replace')
	}
	out[...,] <- .Matrix
	attributes(out) <-  .AT
	out
}





#' @export
#' @method [[<- mfactor
`[[<-.mfactor` <- `[<-.mfactor`

