<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Jason Thorpe [jdthorpe_at_gmail_dot_com]" />

<meta name="date" content="2015-04-20" />

<title>An Introduction to multi-factors</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link rel="stylesheet" href="/Library/Frameworks/R.framework/Versions/3.1/Resources/library/rmarkdown/rmarkdown/templates/html_vignette/resources/vignette.css" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">An Introduction to multi-factors</h1>
<h4 class="author"><em>Jason Thorpe [jdthorpe_at_gmail_dot_com]</em></h4>
<h4 class="date"><em>2015-04-20</em></h4>
</div>


<div id="why-mfactors" class="section level1">
<h1>Why mfactors?</h1>
<p>Multi-factors came about in order to deal with character vectors whose contents are delimited fields, whose entries <em>should</em> be limited to a fixed set of values (levels), and whose values <em>should</em> be limited to a single value per entry. If we we remove the words ‘delimited’ and ‘<em>should</em>’ from the prevous sentance, we would have a good definition of a <code>factor</code> variable.</p>
<p>However, the process that generates such data may not be constrained. Specifically the data that motivated this class were derives from paper surveys in which individuals were asked to pick ‘the single best response’ to dozens of questions, but often indicted more than one response. If this same questionnaire were administered electronically, the responses could have been been constrained, but sadly, this was not the case.</p>
<div id="alternatives." class="section level2">
<h2>Alternatives.</h2>
<p>Before describing what multi-factors are and how they work, there are several obvious alternatives that may suffice in some cases, including (1) a ragged array, (2) an indicator matrix, (3) a data.frame with indicator variables, or a character vector with delimited.</p>
<p>To begin with an example, lets say we ask 3 individuals, to answer the quesiton “How do you feel about the Seattle Seahawks? (a) I don’t like them, (b) I love them, or (c) I’ve never heard of the Seattle Seahawks”. furthermore lets assume that the first respondent replied ‘a’, the second respondent replied ‘b’, and the third respondent replid ‘b’ and ‘c’.</p>
<p>The following are three solutions to modeling these responses, each of which may be preferred in some situations:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># A ragged array</span>
(response_list &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>,<span class="kw">c</span>(<span class="st">&#39;b&#39;</span>,<span class="st">&#39;c&#39;</span>)))
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] &quot;a&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] &quot;b&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] &quot;b&quot; &quot;c&quot;</span>

<span class="co"># an indicator matirx</span>
(response_matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(T,F,F,
                             F,T,F,
                             F,T,T),
                             <span class="dt">nrow=</span><span class="dv">3</span>,
                             <span class="dt">byrow=</span>T,
                             <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="dv">1</span>:<span class="dv">3</span>,
                                             <span class="kw">c</span>(<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>,<span class="st">&#39;c&#39;</span>))))
<span class="co">#&gt;       a     b     c</span>
<span class="co">#&gt; 1  TRUE FALSE FALSE</span>
<span class="co">#&gt; 2 FALSE  TRUE FALSE</span>
<span class="co">#&gt; 3 FALSE  TRUE  TRUE</span>

<span class="co"># a data.frame with indicator variables. </span>
(response_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="kw">c</span>(T,F,F),
                           <span class="dt">b =</span> <span class="kw">c</span>(F,T,F),
                           <span class="dt">c =</span> <span class="kw">c</span>(F,T,T)))
<span class="co">#&gt;       a     b     c</span>
<span class="co">#&gt; 1  TRUE FALSE FALSE</span>
<span class="co">#&gt; 2 FALSE  TRUE  TRUE</span>
<span class="co">#&gt; 3 FALSE FALSE  TRUE</span>

<span class="co"># A comma delimited set of strings</span>
(response_delim &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>,<span class="st">&#39;b,c&#39;</span>))
<span class="co">#&gt; [1] &quot;a&quot;   &quot;b&quot;   &quot;b,c&quot;</span></code></pre>
</div>
<div id="about-multi-factors-mfactors" class="section level2">
<h2>About Multi-Factors (<code>mfactors</code>)</h2>
<div id="creating-mfactor-variables" class="section level3">
<h3>Creating <code>mfactor</code> variables</h3>
<p>Creating <code>mfactor</code> variables is similar to creating ordinary factors from a character vector, except that the the argument <code>split</code> may be supplied (which is passed to <code>base::strsplit</code>) and is used to split each string into it’s individual elements, as follows:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mfactor)
mf &lt;-<span class="st"> </span><span class="kw">mfactor</span>(<span class="dt">x =</span><span class="kw">c</span>(<span class="ot">NA</span>,<span class="st">&quot;&quot;</span>,<span class="st">&#39;1&#39;</span>,<span class="st">&#39;2&#39;</span>,<span class="st">&#39;3&#39;</span>,<span class="st">&#39;1,2&#39;</span>,<span class="st">&#39;2,3&#39;</span>,<span class="st">&#39;1,2,3&#39;</span>)
    ,<span class="dt">split=</span><span class="st">&#39;,&#39;</span>
    ,<span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&#39;1&#39;</span>,<span class="st">&#39;2&#39;</span>,<span class="st">&#39;3&#39;</span>,<span class="st">&#39;4&#39;</span>)
    ,<span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&#39;Never&#39;</span>,<span class="st">&#39;Rarely&#39;</span>,<span class="st">&#39;Sometimes&#39;</span>,<span class="st">&#39;Often&#39;</span>)
    ,<span class="dt">ordered =</span> <span class="ot">TRUE</span>)
mf
<span class="co">#&gt; [1] &lt;NA&gt;                   &lt;None&gt;                 Never                 </span>
<span class="co">#&gt; [4] Rarely                 Sometimes              Never;Rarely          </span>
<span class="co">#&gt; [7] Rarely;Sometimes       Never;Rarely;Sometimes</span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span></code></pre>
<p>Notice that several things happend in this call to mfactor.</p>
<ul>
<li>The elements of the argument <code>x</code> were separated using the regular expression supplied to the argument <code>split</code></li>
<li>The resulting elements were checked against the expected values supplied in the <code>levels</code> argument, and the user would be warned if additonal values were observed in <code>x</code> (after splitting <code>x</code> of course)</li>
<li>The values were re-labeled with labels supplied to the argument <code>labels</code></li>
</ul>
<p>At each step many common errors (e.g. invalid values in the argumen <code>x</code>) are checked, and warnings or error issued in response, which can help with the data cleaning process.</p>
<p>Many other types of objects can also be coerced to multi-factors via mfactors, as in:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># A ragged array</span>
<span class="kw">mfactor</span>(response_delim,
        <span class="dt">split =</span> <span class="st">&#39;,&#39;</span>,
        <span class="dt">levels=</span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>,<span class="st">&#39;c&#39;</span>),
        <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;Love&#39;em&quot;</span>,<span class="st">&quot;Hate&#39;em&quot;</span>,<span class="st">&quot;Who?&quot;</span>))
<span class="co">#&gt; [1] Love&#39;em      Hate&#39;em      Hate&#39;em;Who?</span>
<span class="co">#&gt; Levels: Love&#39;em Hate&#39;em Who?</span>
<span class="kw">mfactor</span>(response_list,
        <span class="dt">levels=</span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>,<span class="st">&#39;c&#39;</span>),
        <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;Love&#39;em&quot;</span>,<span class="st">&quot;Hate&#39;em&quot;</span>,<span class="st">&quot;Who?&quot;</span>))
<span class="co">#&gt; [1] Love&#39;em      Hate&#39;em      Hate&#39;em;Who?</span>
<span class="co">#&gt; Levels: Love&#39;em Hate&#39;em Who?</span>
<span class="co"># Note that by default the levels are taken from the column names</span>
<span class="co"># for data.frames and matricies (if they exist)</span>
<span class="kw">mfactor</span>(response_matrix,
        <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;Love&#39;em&quot;</span>,<span class="st">&quot;Hate&#39;em&quot;</span>,<span class="st">&quot;Who?&quot;</span>))
<span class="co">#&gt;            1            2            3 </span>
<span class="co">#&gt;      Love&#39;em      Hate&#39;em Hate&#39;em;Who? </span>
<span class="co">#&gt; Levels: Love&#39;em Hate&#39;em Who?</span>
<span class="kw">mfactor</span>(response_df,
        <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;Love&#39;em&quot;</span>,<span class="st">&quot;Hate&#39;em&quot;</span>,<span class="st">&quot;Who?&quot;</span>))
<span class="co">#&gt; [1] Love&#39;em      Hate&#39;em;Who? Who?        </span>
<span class="co">#&gt; Levels: Love&#39;em Hate&#39;em Who?</span></code></pre>
</div>
<div id="coersion-to-ordinary-factors" class="section level3">
<h3>Coersion to Ordinary Factors</h3>
<p>Typically the goal of data cleaning is to remove anamalies like the ones previously discucssed, so mfactrs are able to be converted to orinary factors using ‘as.factor’.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#conversion to factor types</span>
<span class="kw">as.factor</span>(mf)
<span class="co">#&gt; [1] &lt;NA&gt;                   &lt;None&gt;                 Never                 </span>
<span class="co">#&gt; [4] Rarely                 Sometimes              Never;Rarely          </span>
<span class="co">#&gt; [7] Rarely;Sometimes       Never;Rarely;Sometimes</span>
<span class="co">#&gt; 8 Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; ... &lt; Never;Rarely;Sometimes</span>
<span class="kw">as.factor</span>(mf,<span class="dt">sep =</span> <span class="st">&#39;|&#39;</span>)
<span class="co">#&gt; [1] &lt;NA&gt;                   &lt;None&gt;                 Never                 </span>
<span class="co">#&gt; [4] Rarely                 Sometimes              Never|Rarely          </span>
<span class="co">#&gt; [7] Rarely|Sometimes       Never|Rarely|Sometimes</span>
<span class="co">#&gt; 8 Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; ... &lt; Never|Rarely|Sometimes</span></code></pre>
<p>The above conversions were not very useful, since, except for the fact that the codes were exchanged for labels, the data are in the same shape they were at the beining of this exercise.</p>
<p>The real power of multi-factors comes from the fact that we can supply an <em>aggregating function</em>, which returns a single value when supplied a vector input. Examples of aggregating functions include <code>min</code>,<code>max</code>, and <code>median</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># The &#39;smallest&#39; value from each element:</span>
<span class="kw">as.factor</span>(mf,min) <span class="co"># or equivelently: min(mf)</span>
<span class="co">#&gt; [1] &lt;NA&gt;      &lt;None&gt;    Never     Rarely    Sometimes Never     Rarely   </span>
<span class="co">#&gt; [8] Never    </span>
<span class="co">#&gt; Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; Often</span>
<span class="co"># The &#39;largest&#39; value from each element:</span>
<span class="kw">as.factor</span>(mf,max) <span class="co"># or equivelently: max(mf)</span>
<span class="co">#&gt; [1] &lt;NA&gt;      &lt;None&gt;    Never     Rarely    Sometimes Rarely    Sometimes</span>
<span class="co">#&gt; [8] Sometimes</span>
<span class="co">#&gt; Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; Often</span>
<span class="co"># this median value provided (missing if even number of values provided)</span>
<span class="kw">as.factor</span>(mf,median) 
<span class="co">#&gt; Warning in as.factor.mfactor(mf, median): NAs introduced by coersion from</span>
<span class="co">#&gt; levels:&quot;Never;Rarely&quot;, &quot;Rarely;Sometimes&quot;</span>
<span class="co">#&gt; [1] &lt;NA&gt;      &lt;None&gt;    Never     Rarely    Sometimes &lt;NA&gt;      &lt;NA&gt;     </span>
<span class="co">#&gt; [8] Rarely   </span>
<span class="co">#&gt; Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; Often</span></code></pre>
<p>Did you notice that in the last example, supplying <code>median</code> as the aggregaing function introduced meissing values in <code>mf</code> and a warning stating <code>Warning in as.factor.mfactor(mf, median): NAs introduced by coersion from levels:&quot;Never;Rarely&quot;, &quot;Rarely;Sometimes&quot;</code>? This happed because aggregaging functions <em>should</em> return an integer between zero and <code>length(levels(mf))</code> or a mising value), but in this case median returned a non integer value. Because the <code>median</code> of the selected values is often desirable, the <code>mfactor</code> package includes 3 aggregating functions which avoid this problem.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># the median value in the absence of ties, and the upper value otherwise</span>
<span class="kw">as.factor</span>(mf,upper.median)
<span class="co">#&gt; [1] &lt;NA&gt;      &lt;None&gt;    Never     Rarely    Sometimes Rarely    Sometimes</span>
<span class="co">#&gt; [8] Rarely   </span>
<span class="co">#&gt; Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; Often</span>

<span class="co"># the median value in the absence of ties, and the lower median otherwise</span>
<span class="kw">as.factor</span>(mf,lower.median)
<span class="co">#&gt; [1] &lt;NA&gt;      &lt;None&gt;    Never     Rarely    Sometimes Never     Rarely   </span>
<span class="co">#&gt; [8] Rarely   </span>
<span class="co">#&gt; Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; Often</span>

<span class="co"># the median value in the absence of ties, otherwise a random selection from </span>
<span class="co"># the values closest to the arethmetic median.</span>
<span class="kw">as.factor</span>(mf,median.random)
<span class="co">#&gt; [1] &lt;NA&gt;      &lt;None&gt;    Never     Rarely    Sometimes Rarely    Rarely   </span>
<span class="co">#&gt; [8] Rarely   </span>
<span class="co">#&gt; Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; Often</span></code></pre>
<p>User defined aggregating functions can also be used</p>
<pre class="sourceCode r"><code class="sourceCode r">AGG &lt;-<span class="st"> </span>function(x)<span class="kw">floor</span>(<span class="kw">median</span>(x)[<span class="dv">1</span>])
<span class="kw">as.factor</span>(mf,AGG)
<span class="co">#&gt; [1] &lt;NA&gt;      &lt;None&gt;    Never     Rarely    Sometimes Never     Rarely   </span>
<span class="co">#&gt; [8] Rarely   </span>
<span class="co">#&gt; Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; Often</span></code></pre>
<p>or alternatively, a string indicating the value to be assigned to each mutipliy-valued element can be specified</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.factor</span>(mf,<span class="dt">collapse=</span><span class="st">&#39;&lt;Multiple-Values&gt;&#39;</span>)
<span class="co">#&gt; [1] &lt;NA&gt;              &lt;None&gt;            Never             Rarely           </span>
<span class="co">#&gt; [5] Sometimes         &lt;Multiple-Values&gt; &lt;Multiple-Values&gt; &lt;Multiple-Values&gt;</span>
<span class="co">#&gt; 6 Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; ... &lt; &lt;Multiple-Values&gt;</span></code></pre>
</div>
<div id="setting-coersion-options-globally" class="section level3">
<h3>Setting Coersion Options Globally</h3>
<p>Default values for the arguments <code>collapse</code>, <code>sep</code>, and <code>none</code> in calls to <code>as.factor</code> and <code>as.ordered</code> can also be set golbally as follows:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">mfactor.sep=</span><span class="st">&quot;::&quot;</span>)
<span class="kw">as.factor</span>(mf)
<span class="co">#&gt; [1] &lt;NA&gt;                     &lt;None&gt;                  </span>
<span class="co">#&gt; [3] Never                    Rarely                  </span>
<span class="co">#&gt; [5] Sometimes                Never::Rarely           </span>
<span class="co">#&gt; [7] Rarely::Sometimes        Never::Rarely::Sometimes</span>
<span class="co">#&gt; 8 Levels: &lt;None&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; ... &lt; Never::Rarely::Sometimes</span>
<span class="kw">options</span>(<span class="dt">mfactor.none=</span> <span class="st">&quot;&lt;&lt;&lt;EMPTY&gt;&gt;&gt;&quot;</span>)
<span class="kw">as.factor</span>(mf)
<span class="co">#&gt; [1] &lt;NA&gt;                     &lt;&lt;&lt;EMPTY&gt;&gt;&gt;             </span>
<span class="co">#&gt; [3] Never                    Rarely                  </span>
<span class="co">#&gt; [5] Sometimes                Never::Rarely           </span>
<span class="co">#&gt; [7] Rarely::Sometimes        Never::Rarely::Sometimes</span>
<span class="co">#&gt; 8 Levels: &lt;&lt;&lt;EMPTY&gt;&gt;&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; ... &lt; Never::Rarely::Sometimes</span>
<span class="kw">options</span>(<span class="dt">mfactor.collapse=</span><span class="st">&quot;&lt;&lt;&lt;Various&gt;&gt;&gt;&quot;</span>)
<span class="kw">as.factor</span>(mf)
<span class="co">#&gt; [1] &lt;NA&gt;          &lt;&lt;&lt;EMPTY&gt;&gt;&gt;   Never         Rarely        Sometimes    </span>
<span class="co">#&gt; [6] &lt;&lt;&lt;Various&gt;&gt;&gt; &lt;&lt;&lt;Various&gt;&gt;&gt; &lt;&lt;&lt;Various&gt;&gt;&gt;</span>
<span class="co">#&gt; 6 Levels: &lt;&lt;&lt;EMPTY&gt;&gt;&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; ... &lt; &lt;&lt;&lt;Various&gt;&gt;&gt;</span>
<span class="kw">options</span>(<span class="dt">mfactor.collapse=</span>median.random)
<span class="kw">as.factor</span>(mf)
<span class="co">#&gt; [1] &lt;NA&gt;        &lt;&lt;&lt;EMPTY&gt;&gt;&gt; Never       Rarely      Sometimes   Never      </span>
<span class="co">#&gt; [7] Sometimes   Rarely     </span>
<span class="co">#&gt; Levels: &lt;&lt;&lt;EMPTY&gt;&gt;&gt; &lt; Never &lt; Rarely &lt; Sometimes &lt; Often</span></code></pre>
<p>Note that arguments supplied to <code>as.factor()</code> will always override global options.</p>
</div>
</div>
<div id="the-none-type" class="section level2">
<h2>The <code>NONE</code> type</h2>
<p>As mentioned earlier, each element of an multi-factor can be thought of as the set of responses to a question indicating “Check all that apply’. In the case that none of the options apply (and there is no option for ‘None’), an element containing no values (”None of these apply to me“) is distinct from a missing value (”User was not asked this question“).</p>
<p>There is a special <code>NONE</code> object which represents the former concept(“None of these apply to me”), which can be used to test for elements in which no response is selected:</p>
<pre class="sourceCode r"><code class="sourceCode r">mf ==<span class="st"> </span>NONE
<span class="co">#&gt; Warning: Incompatible methods (&quot;Ops.ord_mfactor&quot;, &quot;Ops.mfactor&quot;) for &quot;==&quot;</span>
<span class="co">#&gt; [1]    NA  TRUE FALSE FALSE FALSE FALSE FALSE FALSE</span></code></pre>
<p><code>is.none</code> and <code>is.none&lt;-</code> can also be used to query and assign <code>NONE</code> values:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.none</span>(mf)
<span class="co">#&gt; [1]    NA  TRUE FALSE FALSE FALSE FALSE FALSE FALSE</span>
x &lt;-<span class="st"> </span>mf
<span class="kw">is.none</span>(x[<span class="dv">1</span>:<span class="dv">5</span>]) &lt;-<span class="st"> </span>T
x
<span class="co">#&gt; [1] &lt;None&gt;                 &lt;None&gt;                 &lt;None&gt;                </span>
<span class="co">#&gt; [4] &lt;None&gt;                 &lt;None&gt;                 Never;Rarely          </span>
<span class="co">#&gt; [7] Rarely;Sometimes       Never;Rarely;Sometimes</span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span></code></pre>
<p>and the string used to indicate ‘NONE’ values can be set globally</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="st">&#39;mfactor.none&#39;</span>=<span class="st">&#39;&lt;Hello World&gt;&#39;</span>) 
x
<span class="co">#&gt; [1] &lt;Hello World&gt;          &lt;Hello World&gt;          &lt;Hello World&gt;         </span>
<span class="co">#&gt; [4] &lt;Hello World&gt;          &lt;Hello World&gt;          Never;Rarely          </span>
<span class="co">#&gt; [7] Rarely;Sometimes       Never;Rarely;Sometimes</span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span></code></pre>
</div>
<div id="conversion-to-other-types" class="section level2">
<h2>Conversion to other types</h2>
<p>Multi-factors can be coerced to a variety of other types as follows:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Ragged Arrays:</span>
<span class="kw">as.list</span>(mf)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] NA</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; integer(0)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] &quot;Never&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] &quot;Rarely&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[5]]</span>
<span class="co">#&gt; [1] &quot;Sometimes&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[6]]</span>
<span class="co">#&gt; [1] &quot;Never&quot;  &quot;Rarely&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[7]]</span>
<span class="co">#&gt; [1] &quot;Rarely&quot;    &quot;Sometimes&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[8]]</span>
<span class="co">#&gt; [1] &quot;Never&quot;     &quot;Rarely&quot;    &quot;Sometimes&quot;</span>
(mf_ragged_array &lt;-<span class="st"> </span><span class="kw">as.list</span>(mf))
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] NA</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; integer(0)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] &quot;Never&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] &quot;Rarely&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[5]]</span>
<span class="co">#&gt; [1] &quot;Sometimes&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[6]]</span>
<span class="co">#&gt; [1] &quot;Never&quot;  &quot;Rarely&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[7]]</span>
<span class="co">#&gt; [1] &quot;Rarely&quot;    &quot;Sometimes&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[8]]</span>
<span class="co">#&gt; [1] &quot;Never&quot;     &quot;Rarely&quot;    &quot;Sometimes&quot;</span>

<span class="co"># Character Vectors</span>
(mf_character &lt;-<span class="st"> </span><span class="kw">as.character</span>(mf,<span class="dt">sep=</span><span class="st">&#39;|&#39;</span>))
<span class="co">#&gt; [1] NA                       &quot;&lt;None&gt;&quot;                </span>
<span class="co">#&gt; [3] &quot;Never&quot;                  &quot;Rarely&quot;                </span>
<span class="co">#&gt; [5] &quot;Sometimes&quot;              &quot;Never|Rarely&quot;          </span>
<span class="co">#&gt; [7] &quot;Rarely|Sometimes&quot;       &quot;Never|Rarely|Sometimes&quot;</span>

<span class="co"># Indicator Matricies.</span>
(mf_matrix &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(mf))
<span class="co">#&gt;      Never Rarely Sometimes Often</span>
<span class="co">#&gt; [1,]    NA     NA        NA    NA</span>
<span class="co">#&gt; [2,] FALSE  FALSE     FALSE FALSE</span>
<span class="co">#&gt; [3,]  TRUE  FALSE     FALSE FALSE</span>
<span class="co">#&gt; [4,] FALSE   TRUE     FALSE FALSE</span>
<span class="co">#&gt; [5,] FALSE  FALSE      TRUE FALSE</span>
<span class="co">#&gt; [6,]  TRUE   TRUE     FALSE FALSE</span>
<span class="co">#&gt; [7,] FALSE   TRUE      TRUE FALSE</span>
<span class="co">#&gt; [8,]  TRUE   TRUE      TRUE FALSE</span></code></pre>
<p>As a bit of syntactic sugar, a single column of the indicator matrix can be extracted using the <code>$</code> operator</p>
<pre class="sourceCode r"><code class="sourceCode r">mf$Sometimes
<span class="co">#&gt; [1]    NA FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE</span></code></pre>
</div>
<div id="algebraic-operators" class="section level2">
<h2>Algebraic Operators</h2>
<p>The operators <code>+</code> and <code>-</code> are defined for multifactors that share a common set of <code>levels()</code>, which can be thought of as <code>Vectorize</code>d versions <code>union</code> and <code>setdiff</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">
(x &lt;-<span class="st"> </span><span class="kw">mfactor</span>(letters[<span class="dv">1</span>:<span class="dv">6</span>],<span class="dt">levels =</span> letters[<span class="dv">1</span>:<span class="dv">10</span>])) <span class="co">#length = 6</span>
<span class="co">#&gt; [1] a b c d e f</span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span>
(y &lt;-<span class="st"> </span><span class="kw">mfactor</span>(letters[<span class="dv">8</span>:<span class="dv">3</span>],<span class="dt">levels =</span> letters[<span class="dv">1</span>:<span class="dv">10</span>])) <span class="co">#length = 6</span>
<span class="co">#&gt; [1] h g f e d c</span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span>
(q &lt;-<span class="st"> </span><span class="kw">mfactor</span>(letters[<span class="dv">1</span>:<span class="dv">3</span>],<span class="dt">levels =</span> letters[<span class="dv">1</span>:<span class="dv">10</span>])) <span class="co">#length = 3</span>
<span class="co">#&gt; [1] a b c</span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span>
(p &lt;-<span class="st"> </span><span class="kw">mfactor</span>(letters[<span class="dv">1</span>:<span class="dv">5</span>],<span class="dt">levels =</span> letters[<span class="dv">1</span>:<span class="dv">10</span>])) <span class="co">#length = 5</span>
<span class="co">#&gt; [1] a b c d e</span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span>

x +<span class="st"> </span>y
<span class="co">#&gt; [1] a;h b;g c;f d;e d;e c;f</span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span>

<span class="co"># note that the usual recycling rules apply</span>
x +<span class="st"> </span>q 
<span class="co">#&gt; [1] a   b   c   a;d b;e c;f</span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span>

x +<span class="st"> </span>p <span class="co"># Warning: longer object length is not a multiple of shorter object length</span>
<span class="co">#&gt; Warning in Ops.mfactor(x, p): longer object length is not a multiple of</span>
<span class="co">#&gt; shorter object length</span>
<span class="co">#&gt; [1] a   b   c   d   e   a;f</span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span></code></pre>
<p>Type coercion is automatically applied by the <code>+</code> and <code>-</code> operators:</p>
<pre class="sourceCode r"><code class="sourceCode r">x -<span class="st"> &#39;a&#39;</span>
<span class="co">#&gt; [1] &lt;None&gt; b      c      d      e      f     </span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span>
x +<span class="st"> </span><span class="kw">list</span>(<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>) <span class="co"># notice the recycling rule is used because list(&#39;a&#39;,&#39;b&#39;) has length &gt; 1</span>
<span class="co">#&gt; [1] a   b   a;c b;d a;e b;f</span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span>
x +<span class="st"> </span><span class="kw">list</span>(<span class="kw">c</span>(<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>)) <span class="co"># now &#39;a&#39; and &#39;b&#39; are added to each element...</span>
<span class="co">#&gt; [1] a;b   a;b   a;b;c a;b;d a;b;e a;b;f</span>
<span class="co">#&gt; Levels: a b c d e f g h i j</span></code></pre>
</div>
<div id="comparisons-operators" class="section level2">
<h2>Comparisons operators</h2>
<p>Comparisons are available for ordered multi-factors however, these can be somewhat non-intuitive. There equality</p>
<pre class="sourceCode r"><code class="sourceCode r">mf2 &lt;-<span class="st"> </span>mf
mf &lt;<span class="st">  </span>mf2 <span class="co"># implemented as max(mf) &lt;  min(mf2)</span>
<span class="co">#&gt; [1]    NA    NA FALSE FALSE FALSE FALSE FALSE FALSE</span>
mf &lt;=<span class="st"> </span>mf2 <span class="co"># implemented as max(mf) &lt;= min(mf2)</span>
<span class="co">#&gt; [1]    NA    NA  TRUE  TRUE  TRUE FALSE FALSE FALSE</span>
mf &gt;<span class="st">  </span>mf2 <span class="co"># implemented as min(mf) &gt;  max(mf2)</span>
<span class="co">#&gt; [1]    NA    NA FALSE FALSE FALSE FALSE FALSE FALSE</span>
mf &gt;=<span class="st"> </span>mf2 <span class="co"># implemented as min(mf) &gt;= max(mf2)</span>
<span class="co">#&gt; [1]    NA    NA  TRUE  TRUE  TRUE FALSE FALSE FALSE</span></code></pre>
<p>Note that the options <code>mfactor.strict.compare</code> affects how the equaliti operators evalute the comparison:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># the default behavior</span>
<span class="kw">options</span>( <span class="dt">mfactor.strict.compare=</span><span class="ot">TRUE</span>) 
mf ==<span class="st"> </span>mf2 <span class="co"># essentially a vectorized version of `identical(a,b)`</span>
<span class="co">#&gt; [1]   NA TRUE TRUE TRUE TRUE TRUE TRUE TRUE</span>
mf !=<span class="st"> </span>mf2 <span class="co"># essentially a vectorized version of `!identical(a,b)`</span>
<span class="co">#&gt; [1]    NA FALSE FALSE FALSE FALSE FALSE FALSE FALSE</span>

<span class="co"># the alternate behavior</span>
<span class="kw">options</span>( <span class="dt">mfactor.strict.compare=</span><span class="ot">FALSE</span>)
mf ==<span class="st"> </span>mf2 <span class="co"># essentially a vectorized version of `any(a %in%  b)`</span>
<span class="co">#&gt; [1]    NA FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE</span>
mf !=<span class="st"> </span>mf2 <span class="co"># essentially a vectorized version of`!any(a %in%  b)`</span>
<span class="co">#&gt; [1]    NA  TRUE FALSE FALSE FALSE FALSE FALSE FALSE</span></code></pre>
<p>Lastly, there is implied type coercion for the comparison operators</p>
<pre class="sourceCode r"><code class="sourceCode r">mf &lt;<span class="st"> &#39;Sometimes&#39;</span>
<span class="co">#&gt; [1]    NA    NA  TRUE FALSE FALSE FALSE FALSE FALSE</span>
mf &lt;=<span class="st"> &#39;Sometimes&#39;</span>
<span class="co">#&gt; [1]    NA    NA  TRUE  TRUE FALSE  TRUE FALSE FALSE</span>
mf &gt;<span class="st"> &#39;Sometimes&#39;</span>
<span class="co">#&gt; [1]    NA    NA FALSE FALSE  TRUE FALSE FALSE FALSE</span>
mf &gt;=<span class="st"> &#39;Sometimes&#39;</span>
<span class="co">#&gt; [1]    NA    NA FALSE  TRUE  TRUE FALSE  TRUE FALSE</span></code></pre>
<div id="subsets-and-subset-assignment" class="section level3">
<h3>Subsets and Subset Assignment</h3>
<p>Multi-factors behave in a similar way to ordinary factors in terms of subsets and subset assingnment</p>
<pre class="sourceCode r"><code class="sourceCode r">mf[[<span class="dv">2</span>]] 
<span class="co">#&gt; [1] &lt;None&gt;</span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span>
mf[<span class="dv">2</span>:<span class="dv">4</span>]
<span class="co">#&gt; [1] &lt;None&gt; Never  Rarely</span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span>
mf[<span class="dv">3</span>] &lt;-<span class="st"> &#39;Sometimes&#39;</span>
mf
<span class="co">#&gt; [1] &lt;NA&gt;                   &lt;None&gt;                 Sometimes             </span>
<span class="co">#&gt; [4] Rarely                 Sometimes              Never;Rarely          </span>
<span class="co">#&gt; [7] Rarely;Sometimes       Never;Rarely;Sometimes</span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span></code></pre>
<p>except that we can assign a list containing subsets of <code>levels(x)</code> when assiging values to a subset of a multi-factor.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># subset assignment</span>
mf[[<span class="dv">8</span>]] &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">c</span>(<span class="st">&#39;Sometimes&#39;</span>,<span class="st">&#39;Often&#39;</span>)) <span class="co"># a new multi factor level</span>
mf
<span class="co">#&gt; [1] &lt;NA&gt;             &lt;None&gt;           Sometimes        Rarely          </span>
<span class="co">#&gt; [5] Sometimes        Never;Rarely     Rarely;Sometimes Sometimes;Often </span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span>

<span class="co"># if a list is assigned, recycling happens at the list-element level</span>
mf[<span class="dv">1</span>:<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">c</span>(<span class="st">&#39;Never&#39;</span>,<span class="st">&#39;Often&#39;</span>))
mf
<span class="co">#&gt; [1] Never;Often      Never;Often      Sometimes        Rarely          </span>
<span class="co">#&gt; [5] Sometimes        Never;Rarely     Rarely;Sometimes Sometimes;Often </span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span>

<span class="co"># if a vector is assigned, recycling happens at the vector-element level</span>
mf[<span class="dv">6</span>:<span class="dv">10</span>] &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;Sometimes&#39;</span>,<span class="st">&#39;Often&#39;</span>)
<span class="co">#&gt; Warning in x[...] &lt;- m: number of items to replace is not a multiple of</span>
<span class="co">#&gt; replacement length</span>
mf
<span class="co">#&gt;  [1] Never;Often Never;Often Sometimes   Rarely      Sometimes  </span>
<span class="co">#&gt;  [6] Sometimes   Often       Sometimes   Often       Sometimes  </span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span>

<span class="co"># invalid factor level assignment creates missing values and issues a warning</span>
mf[<span class="dv">9</span>:<span class="dv">10</span>] &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;hello&#39;</span>,<span class="st">&#39;world&#39;</span>)
<span class="co">#&gt; Warning in `[&lt;-.mfactor`(`*tmp*`, 9:10, value = c(&quot;hello&quot;, &quot;world&quot;)):</span>
<span class="co">#&gt; invalid factor level, NAs generated</span></code></pre>
</div>
</div>
<div id="miscelaneous" class="section level2">
<h2>Miscelaneous</h2>
<p>Like other vectors, multi-factors can be extended or truncated using the <code>length&lt;-</code>, missing values can be set queried and set via <code>is.na</code> and <code>is.na&lt;-</code>, and the names can be set and queried via <code>names</code> and <code>names&lt;-</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># extension or truncation</span>
<span class="kw">length</span>(mf)
<span class="co">#&gt; [1] 10</span>
<span class="kw">length</span>(mf) &lt;-<span class="st"> </span><span class="dv">20</span>
<span class="kw">length</span>(mf)
<span class="co">#&gt; [1] 20</span>
<span class="kw">length</span>(mf) &lt;-<span class="st"> </span><span class="dv">5</span>
<span class="kw">length</span>(mf)
<span class="co">#&gt; [1] 5</span>

<span class="co"># setting and identifying missing values</span>
<span class="kw">is.na</span>(mf)
<span class="co">#&gt; [1] FALSE FALSE FALSE FALSE FALSE</span>
<span class="kw">is.na</span>(mf) &lt;-<span class="st"> </span><span class="dv">5</span>
<span class="kw">is.na</span>(mf)
<span class="co">#&gt; [1] FALSE FALSE FALSE FALSE  TRUE</span>

<span class="co"># element names</span>
<span class="kw">names</span>(mf) &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&#39;item&#39;</span>,<span class="kw">seq_along</span>(mf))
mf
<span class="co">#&gt;       item1       item2       item3       item4       item5 </span>
<span class="co">#&gt; Never;Often Never;Often   Sometimes      Rarely        &lt;NA&gt; </span>
<span class="co">#&gt; Levels: Never &lt; Rarely &lt; Sometimes &lt; Often</span></code></pre>
<p>And like factors, the levels can be queried and reassigned via <code>levels</code> and <code>levels&lt;-</code></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(mf)
<span class="co">#&gt; [1] &quot;Never&quot;     &quot;Rarely&quot;    &quot;Sometimes&quot; &quot;Often&quot;</span>
<span class="kw">levels</span>(mf) &lt;-<span class="st"> </span>LETTERS[<span class="dv">15</span>:<span class="dv">18</span>]
<span class="kw">levels</span>(mf)
<span class="co">#&gt; [1] &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot;</span></code></pre>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
